### communicators

A message is successfully received if:
- `recv_type` = `send_type`
- `recv_buf_sz` >= `send_buf_sz` (i can send less bytes than i can receive)

A receiver can get a message without knowing:
- the amount of data in it
- the sender (wildcard `MPI_ANY_SOURCE`)
- the tag of the message (wildcard `MPI_ANY_TAG`)

To find out, you can operate on `&status`, an `MPI_Status`-type argument (the last argument of an `MPI_Recv`)
- `status.MPI_SOURCE` to find the source
- `status.MPI_TAG` to find the tag
- it also offers `status.MPI_ERROR` (to find the error ?)

### issues with send and receive
Some things are well-defined (tags, id), but others have been left up to the implementation:

- MPI_Send - non so se il messaggio sia partito o arrivato - passo all'istruzione successiva, e il messaggio potrebbe essere ancora all'interno del processo - l'unica garanzia che ho è che, quando eseguo l'istruzione successiva, se modifico il buffer da inviare/inviato, i dati inviati saranno comunque corretti, anche se il messaggio non dovesse essere partito (forse MPI fa una copia, o per altri motivi)
	- different implementations handle this differently

MPI ha un buffer per i messaggi inviati ma non ricevuti da nessuno (nessuno ha chiamato la funzione con i parametri giusti) - ma, se il buffer è troppo grande, chi invia controlla se il ricevente è pronto a ricevere (rendezvous).

La receive si blocca fino a quando il messaggio non viene ricevuto (quindi, quando termina, ho la garanzia che il buffer sia stato ricevuto).
- if a process tries to receive a message and there's no matching send, the process will hang
- if a call to MPI_Send blocks and there's no matching receive, the sending process can hang

>[!question] what happens when you do a send?
> ![[send-request.png|center|500]]


